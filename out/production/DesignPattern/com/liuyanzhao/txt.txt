本文主要是对23种设计模式进行总结

Java代码示例在完善中 ：https://github.com/saysky/DesignPattern

有时间就会写一些例子，尽量把写得完整些。

后面也会把每种设计模式的 UML 图绘制出来。

设计模式六大原则


1. 开放封闭原则：对扩展开放，对修改封闭，意即程序拓展时不要动原有的代码

2. LSP原则：任何基类可以出现的地方，子类一定可以出现

3. 依赖倒置原则：使用接口，依赖于抽象而不是具体

4. 接口隔离原则：为了解耦，使用多个相互隔离的接口

5. 迪米特法则：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

6. CRP法则：尽量使用合成/聚合的方式，而不是使用继承。

分类

1.创建型模式（在创建对象的过程中尽量隐藏创建细节，不直接使用new）

工厂模式（Factory Pattern）
抽象工厂模式（Abstract Factory Pattern）
单例模式（Singleton Pattern）
建造者模式（Builder Pattern）
原型模式（Prototype Pattern)

?2.结构型模式（主要关注类和对象的继承、组合）

适配器模式（Adapter Pattern）
桥接模式（Bridge Pattern）
过滤器模式（Filter、Criteria Pattern）
组合模式（Composite Pattern）
装饰器模式（Decorator Pattern）
外观模式（Facade Pattern）
享元模式（Flyweight Pattern）
代理模式（Proxy Pattern）

3.行为型模式（关注对象之间的通信）

责任链模式（Chain of Responsibility Pattern）
命令模式（Command Pattern）-
解释器模式（Interpreter Pattern）-
迭代器模式（Iterator Pattern）
中介者模式（Mediator Pattern）-
备忘录模式（Memento Pattern）
观察者模式（Observer Pattern）
状态模式（State Pattern）
空对象模式（Null Object Pattern）-
策略模式（Strategy Pattern）
模板模式（Template Pattern）
访问者模式（Visitor Pattern）




详细说明

1. 工厂模式
现在要创建一些对象，他们都实现了某个接口或者继承了某个类。我们不在需要的时候使用new操作符，而是把创建的操作让一个“工厂类”完成，我们在需要新对象时只需要把需要的东西的名字以参数形式传递给工厂类就行了，而不用去管怎么创建的。

?2. 抽象工厂模式
在工厂模式中，一个工厂类只生产实现某个接口或者继承了某个类的对象，也就是具体工厂生产具体对象，如果建立一个抽象工厂类和若干个具体工厂，每个具体工厂负责产生一类对象，就成了抽象工厂模式。就是一个抽象工厂类可以生产多种类型的对象，具体每种类型的对象怎么生成，要用一个专门的工厂类来决定。

3. 单例模式
一个类，他虽然有构造方法，但是把它设定为private，不能被外界使用。这个类只存在一个实例，保存在这个类自己的一个静态字段里，如果要用这个类的实例属性、实例方法，都通过这个静态字段访问这个唯一的实例来实现。

4. 建造者模式
现在要创建一个很复杂的对象，我们把这个工作分开来做，先定义并实现一个建造者类，在这个类中实现构建这个对象所需要的全部方法。再定义并实现一个导演类，把一个建造者类传给它，让它负责这些方法调用的逻辑次序和对象的组合，然后统一给客户端返回一个生成好的复杂对象。

5. 原型模式
已经有了一个对象了，我们创建对象时直接复制它，不需要新建了。

6. 适配器模式
一个类和另一个类有一些相似的操作，但是它们的形式是不一致的，需要有一个东西把它包裹起来，变成另一种比较合适的形式。

类适配：创建新类，继承源类，并实现新接口，例如
```
class adapter extends oldClass implements newFunc{}
```
对象适配：创建新类持源类的实例，并实现新接口，例如
```
class adapter implements newFunc { private oldClass oldInstance ;}
```
接口适配：创建新的抽象类实现旧接口方法。例如
```
abstract class adapter implements oldClassFunc { void newFunc();}
```

7. 装饰器模式
一个类有一些方法，但是我们想让这些方法调用的时候多执行一些东西，于是可以定义一个装饰器的类，它和被修饰的类同时一个类的子类或是一个接口的实现，然后将这个被修饰的类委托给这个装饰器类，如果想使用这个修饰后的方法，只需要调用这个修饰器的方法就可以了。

8. 代理模式
我想访问一个对象，但是这个对象出于多种考虑，比如细节复杂、需要控制访问、隐藏细节等，不能让别人直接使用，必须要使用一个中间层性质的代理类，对这个对象的所有访问都由这个代理类来完成。

9. 外观模式
我现在有一个成套的系统，有若干接口、类，但是直接操作这些类是一个很复杂的过程，于是额外再定义一个总结性质的类，给几个比较有概括性的、简洁的方法去操作这个系统，以此来简化访问。

10. 桥接模式
如果我现在有一个抽象的父类，和一些具体的子类，本来他们应该是一个继承的关系，但我认为这样会使两个类耦合过紧，于是强行使用委派、组合的方式，使两者可以相对独立的变化。具体就是在抽象类中实现一些基本操作，然后把一些需要细分的操作委派出去，可以把那些原来的子类统一到一个接口里，然后把这个接口和原来的父类组合。

11. 组合模式
定义一个比较宽泛的类，一个具体的对象属于这个类，把这些具体的对象按一定方式组合起来也属于这个类。

12. 享元模式
很多对象都需要用同一个对象，但他们都自己创建了一份保存，这样会造成内存大量浪费。把这一部分抽出来，只创建一份，供这些对象共同使用，就可以节省内存。

13. 观察者模式
一组对象依赖于某一个对象，这个对象的状态的更新会影响这一组对象，于是把这组对象称为观察者，放在被观察者一个不定长数组的字段里，两者分别保存对方的引用，被观察者更新时会调用观察者的方法来提醒观察者。

14. 访问者模式
我现在有一个类，上面有一些操作，但是我不想把它写到这个类里，所以我把这个功能单独拿出来，需要执行这个功能的时候，把这个类的引用给那个功能类，让那个功能类操作这个类。

15. 状态模式
一个类，他的一些操作的具体过程是根据它当前的状态来决定的，而这个状态取决于当前环境的上下文。

16. 备忘录模式
对一个类的对象的状态进行可持久化处理，方法是另外设立一个备忘录类，记录状态的变化过程，然后就可以恢复到某个历史状态。

17. 策略模式
对于一个操作，实现它的算法有很多，我把这些算法每个都建立一个类，实现那个方法类的接口，在需要执行这个操作的地方，要运用某个算法，只需要把那个算法对应的类传进去就行了。

18. 模板模式
一个操作，它的每一步可能有细节上的区别，但是它的大概框架是确定的，在执行各个步骤的时候，先用一些抽象类放在对应的位置，等随后再定义一些具体类去填充它。

19. 迭代器模式
一个类，里面有一组元素，要按照某个次序一次访问这些元素，于是单独设立一个迭代器，无需暴露内部复杂实现，直接告诉你当前是哪个元素、下一个是哪个元素，就可以按照这种特定次序遍历这些元素了。

20. 过滤器模式

21. 责任链模式

22. 命令模式

23. 解释器模式

24. 中介者模式

25. 空对象模式
